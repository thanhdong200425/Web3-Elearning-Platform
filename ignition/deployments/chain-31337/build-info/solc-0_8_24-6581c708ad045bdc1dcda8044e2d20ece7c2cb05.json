{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-6581c708ad045bdc1dcda8044e2d20ece7c2cb05",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/ElearningPlatform.sol": "project/contracts/ElearningPlatform.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/ElearningPlatform.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ICertificateNFT {\n    function safeMint(\n        address to,\n        string memory tokenURI_\n    ) external returns (uint256 tokenId);\n}\n\ncontract ElearningPlatform {\n    ICertificateNFT public certificateNFT;\n\n    constructor(address _certificateNFTAddress) {\n        require(_certificateNFTAddress != address(0), \"Invalid NFT address\");\n        certificateNFT = ICertificateNFT(_certificateNFTAddress);\n    }\n\n    // Define a Course struct to hold course details, only ElearningPlatform contract use this struct\n    struct Course {\n        uint256 id;\n        address instructor;\n        uint256 price;\n        string title;\n        string contentCid;\n    }\n\n    uint256 public nextCourseId = 1;\n    mapping(uint256 => Course) public courses;\n\n    // Mapping from student address => { courseId => purchased }\n    mapping(address => mapping(uint256 => bool)) public purchases;\n\n    // Mapping from student address => array of purchased course IDs\n    mapping(address => uint256[]) public studentCourses;\n\n    // Mapping from student address => courseId => index in studentCourses array\n    mapping(address => mapping(uint256 => uint256)) public studentCourseIndex;\n\n    uint256[] public courseIds;\n\n    // Event to notify when a course is created\n    event CourseCreated(\n        uint256 indexed courseId,\n        address indexed instructor,\n        string title,\n        uint256 price,\n        string contentCid\n    );\n\n    // Event to notify when a course is purchased\n    event CoursePurchased(\n        address indexed student,\n        uint256 indexed courseId,\n        uint256 price\n    );\n\n    function getAllCourse() public view returns (Course[] memory) {\n        Course[] memory allCourses = new Course[](courseIds.length);\n        for (uint256 i = 0; i < courseIds.length; i++) {\n            allCourses[i] = courses[courseIds[i]];\n        }\n        return allCourses;\n    }\n\n    function createCourse(\n        string calldata _title,\n        uint256 _price,\n        string calldata _contentCid\n    ) public returns (uint256 courseId) {\n        require(bytes(_title).length != 0, \"Title is required\");\n        require(bytes(_contentCid).length != 0, \"Content CID is required\");\n        courseId = nextCourseId++;\n        courses[courseId] = Course({\n            id: courseId,\n            instructor: msg.sender,\n            price: _price,\n            title: _title,\n            contentCid: _contentCid\n        });\n\n        emit CourseCreated(courseId, msg.sender, _title, _price, _contentCid);\n\n        return courseId;\n    }\n\n    function purchaseCourse(uint256 _courseId) public payable {\n        Course memory course = courses[_courseId];\n        require(course.id != 0, \"Course does not exist\");\n        require(!purchases[msg.sender][_courseId], \"Course already purchased\");\n        require(msg.value >= course.price, \"Insufficient payment\");\n\n        // Mark as purchased\n        purchases[msg.sender][_courseId] = true;\n\n        // Add to student's course list\n        studentCourseIndex[msg.sender][_courseId] = studentCourses[msg.sender]\n            .length;\n        studentCourses[msg.sender].push(_courseId);\n\n        // Transfer payment to instructor\n        (bool sent, ) = course.instructor.call{value: course.price}(\"\");\n        require(sent, \"Failed to send payment to instructor\");\n\n        // Refund excess payment if any\n        if (msg.value > course.price) {\n            (bool refundSent, ) = msg.sender.call{\n                value: msg.value - course.price\n            }(\"\");\n            require(refundSent, \"Failed to refund excess payment\");\n        }\n\n        emit CoursePurchased(msg.sender, _courseId, course.price);\n    }\n\n    function hasPurchasedCourse(\n        address _student,\n        uint256 _courseId\n    ) public view returns (bool) {\n        return purchases[_student][_courseId];\n    }\n\n    function getPurchasedCourses(\n        address _student\n    ) public view returns (uint256[] memory) {\n        return studentCourses[_student];\n    }\n\n    function getCourseContentCid(\n        uint256 _courseId\n    ) public view returns (string memory) {\n        require(courses[_courseId].id != 0, \"Course does not exist\");\n        return courses[_courseId].contentCid;\n    }\n\n    function getPurchasedCourseContentCid(\n        address _student,\n        uint256 _courseId\n    ) public view returns (string memory) {\n        require(purchases[_student][_courseId], \"Course not purchased\");\n        return courses[_courseId].contentCid;\n    }\n}\n"
      }
    }
  }
}